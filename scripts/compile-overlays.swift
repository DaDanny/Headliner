#!/usr/bin/env swift

import Foundation

/// Build script to compile overlay templates into OverlayPreset instances
/// This script runs during the build process to convert SwiftUI templates
/// into the format needed by the camera extension.

print("🎨 Compiling overlay templates...")

// Get the project directory (this script runs from the project root)
let projectDir = FileManager.default.currentDirectoryPath
let templatesDir = "\(projectDir)/OverlayTemplates"
let outputDir = "\(projectDir)/Headliner/Generated"

// Create output directory if it doesn't exist
try? FileManager.default.createDirectory(atPath: outputDir, withIntermediateDirectories: true)

// Find all template files
let templateFiles = try FileManager.default.contentsOfDirectory(atPath: templatesDir)
    .filter { $0.hasSuffix("Template.swift") && $0 != "BaseOverlayTemplate.swift" }

print("📁 Found \(templateFiles.count) template files: \(templateFiles.joined(separator: ", "))")

// Generate the compiled overlays file
var compiledOverlaysContent = """
//
//  CompiledOverlays.swift
//  Headliner
//
//  Auto-generated file containing compiled overlay templates.
//  DO NOT EDIT - this file is generated by the build script.
//  To modify overlays, edit the template files in OverlayTemplates/ directory.
//

import Foundation

/// Auto-generated overlay presets compiled from template files
struct CompiledOverlays {
    
    /// All available overlay presets
    static let allPresets: [OverlayPreset] = [
"""

// Process each template file
for templateFile in templateFiles {
    let templateName = templateFile.replacingOccurrences(of: "Template.swift", with: "")
    let className = "\(templateName)Template"
    
    print("🔨 Compiling \(className)...")
    
    // Add the preset to the array
    compiledOverlaysContent += """
        
        // \(className)
        \(className).compile(),
"""
}

// Close the array and add helper methods
compiledOverlaysContent += """
    ]
    
    /// Get preset by ID
    static func preset(withId id: String) -> OverlayPreset? {
        return allPresets.first { $0.id == id }
    }
    
    /// Get default preset
    static var defaultPreset: OverlayPreset {
        return allPresets.first ?? OverlayPreset(
            id: "fallback",
            name: "Fallback",
            nodes: [],
            layout: OverlayLayout(
                widescreen: [],
                fourThree: []
            )
        )
    }
}
"""

// Write the compiled file
let outputPath = "\(outputDir)/CompiledOverlays.swift"
try compiledOverlaysContent.write(toFile: outputPath, atomically: true, encoding: .utf8)

// Generate the JSON manifest
print("📄 Generating preset manifest...")

struct PresetManifest: Codable {
    let version: String
    let generatedAt: String
    let presets: [PresetInfo]
}

struct PresetInfo: Codable {
    let id: String
    let name: String
    let description: String
    let templateFile: String
}

// Create preset info for each template
var presetInfos: [PresetInfo] = []
for templateFile in templateFiles {
    let templateName = templateFile.replacingOccurrences(of: "Template.swift", with: "")
    let className = "\(templateName)Template"
    
    // Create preset info with unique IDs to avoid conflicts with built-in presets
    let presetInfo = PresetInfo(
        id: "\(templateName.lowercased())-custom",
        name: "\(templateName) Custom",
        description: "Auto-generated \(templateName) overlay template",
        templateFile: templateFile
    )
    presetInfos.append(presetInfo)
}

// Create the manifest
let manifest = PresetManifest(
    version: "1.0.0",
    generatedAt: ISO8601DateFormatter().string(from: Date()),
    presets: presetInfos
)

// Write the manifest
let manifestPath = "\(outputDir)/PresetManifest.json"
let manifestData = try JSONEncoder().encode(manifest)
try manifestData.write(to: URL(fileURLWithPath: manifestPath))

print("✅ Successfully compiled \(templateFiles.count) templates to \(outputPath)")
print("📄 Generated manifest with \(presetInfos.count) presets to \(manifestPath)")
print("🎯 Ready for use in the camera extension!")
